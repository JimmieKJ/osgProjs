
#include <osg/Geode>
#include <osg/Geometry>
#include <osg/Material>
#include <osg/Vec3>
#include <osg/MatrixTransform>
#include <osg/Texture2D>
#include <osg/PolygonStipple>
#include <osg/TriangleFunctor>
#include <osg/io_utils>

#include <osgDB/ReadFile>
#include <osgDB/WriteFile>

#include <osgGA/TrackballManipulator>

#include <osgViewer/Viewer>

#include <osg/Math>

#include <iostream>
#include <osgUtil/Optimizer>


// This demo illustrates how to create the various different types of geometry that
// the osg::Geometry class can represent.  This demo uses the OpenGL red book diagram of different
// OpenGL Primitives as a template for all the equivalent OpenSceneGraph Primitives.  The OpenSceneGraph
// wraps OpenGL very thinly and therefore uses all the same enum and naming conventions. The coordinate data is also
// wrapped around OpenGL's vertex arrays and draw arrays/elements calls.  Familiarity with
// OpenGL will help you understand the osg::Geometry class which encapsulate all this, or if you
// haven't learned OpenGL yet, learning osg::Geometry will help you understand how OpenGL
// works!

// The osg::Geometry class "is a" subclass of osg::Drawable base class, so is an object that provides
// a draw method for drawing objects in the scene.  osg::Geometry contains all the vertex, normal
// color and texture coordinate arrays required to specify the coordinates of your objects, and the
// primitives join these coordinates together as the points, lines or surfaces that you will see
// rendered on your screen.
//
// This demo is split into two functions, the createScene() function which creates the scene graph
// with the various primitives in it, and the main() which sets up a basic viewer window and
// adds to the it the scene generated by createScene().


struct NormalPrint
{
    void operator() (const osg::Vec3& v1,const osg::Vec3& v2,const osg::Vec3& v3, bool) const
    {
        osg::Vec3 normal = (v2-v1)^(v3-v2);
        normal.normalize();
        std::cout << "\t("<<v1<<") ("<<v2<<") ("<<v3<<") "<<") normal ("<<normal<<")"<<std::endl;
    }
};

// decompose Drawable primitives into triangles, print out these triangles and computed normals.
void printTriangles(const std::string& name, osg::Drawable& drawable)
{
    std::cout<<name<<std::endl;

    osg::TriangleFunctor<NormalPrint> tf;
    drawable.accept(tf);

    std::cout<<std::endl;
}


osg::Node* createScene()
{
    // create the Geode (Geometry Node) to contain all our osg::Geometry objects.
    osg::Geode* geode = new osg::Geode();

    // following are separate blocks for creating POINTS, LINES, LINE_STRIP, LINE_LOOP, POLYGON, QUADS,
    // QUAD_STRIP, TRIANGLES, TRIANGLE_STRIP and TRIANGLE_FAN primitives. An image of these primitives
    // is provided in the distribution: OpenSceneGraph-Data/Images/primitives.gif.


    // create POINTS
    {
        // create Geometry object to store all the vertices and points primitive.
        osg::Geometry* pointsGeom = new osg::Geometry();

        // create a Vec3Array and add to it all my coordinates.
        // Like all the *Array variants (see include/osg/Array) , Vec3Array is derived from both osg::Array
        // and std::vector<>.  osg::Array's are reference counted and hence sharable,
        // which std::vector<> provides all the convenience, flexibility and robustness
        // of the most popular of all STL containers.
        osg::Vec3Array* vertices = new osg::Vec3Array;

	osg::Vec3 V1=	osg::Vec3(1, 1, 1);
	for (int n=0;n<500000;n++)///////////////1200万顶点的点集合
	{
			//osg::Vec3 VTemp=	osg::Vec3(1+n, 1, 1);
			        vertices->push_back(osg::Vec3(1+n, 1, 1));
		//			  vertices->push_back(osg::Vec3(1, 1+n, 1));
					    vertices->push_back(osg::Vec3(1, 1, 1+n));

						  vertices->push_back(osg::Vec3(1+n, 1+n, 1));
//						    vertices->push_back(osg::Vec3(1+n, 1, 1+n));
							 vertices->push_back(osg::Vec3(1, 1+n, 1+n));

							vertices->push_back(osg::Vec3(1+n, 1+n, 1+n));

							//------------------------------------------------------
							vertices->push_back(osg::Vec3(1-n, 1, 1));
	//						vertices->push_back(osg::Vec3(1, 1-n, 1));
							vertices->push_back(osg::Vec3(1, 1, 1-n));
// 
 							vertices->push_back(osg::Vec3(1-n, 1-n, 1));
//							vertices->push_back(osg::Vec3(1-n, 1, 1-n));
							vertices->push_back(osg::Vec3(1, 1-n, 1-n));

							vertices->push_back(osg::Vec3(1-n, 1-n, 1-n));
	}


        pointsGeom->setVertexArray(vertices);



        // create the color of the geometry, one single for the whole geometry.
        // for consistency of design even one single color must added as an element
        // in a color array.
        osg::Vec4Array* colors = new osg::Vec4Array;
        // add a white color, colors take the form r,g,b,a with 0.0 off, 1.0 full on.
        colors->push_back(osg::Vec4(1.0f,1.0f,0.0f,1.0f));

        // pass the color array to points geometry, note the binding to tell the geometry
        // that only use one color for the whole object.
        pointsGeom->setColorArray(colors, osg::Array::BIND_OVERALL);


        // set the normal in the same way color.
        osg::Vec3Array* normals = new osg::Vec3Array;
        normals->push_back(osg::Vec3(0.0f,-1.0f,0.0f));
        pointsGeom->setNormalArray(normals, osg::Array::BIND_OVERALL);


        // create and add a DrawArray Primitive (see include/osg/Primitive).  The first
        // parameter passed to the DrawArrays constructor is the Primitive::Mode which
        // in this case is POINTS (which has the same value GL_POINTS), the second
        // parameter is the index position into the vertex array of the first point
        // to draw, and the third parameter is the number of points to draw.
        pointsGeom->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::POINTS,0,vertices->size()));
		pointsGeom->setUseDisplayList(false);

        // add the points geometry to the geode.
        geode->addDrawable(pointsGeom);

    }

    osg::ref_ptr<osg::Vec4Array> shared_colors = new osg::Vec4Array;
    shared_colors->push_back(osg::Vec4(1.0f,1.0f,0.0f,1.0f));

	osg::ref_ptr<osg::Vec4Array> shared_colors_Red = new osg::Vec4Array;
	shared_colors_Red->push_back(osg::Vec4(1.0f,0.0f,0.0f,1.0f));

	osg::ref_ptr<osg::Vec4Array> shared_colors_Green = new osg::Vec4Array;
	shared_colors_Green->push_back(osg::Vec4(0.0f,1.0f,0.0f,1.0f));

    // same trick for shared normal.
    osg::ref_ptr<osg::Vec3Array> shared_normals = new osg::Vec3Array;
    shared_normals->push_back(osg::Vec3(0.0f,-1.0f,0.0f));



    // Note on vertex ordering.
    // According to the OpenGL diagram vertices should be specified in a clockwise direction.
    // In reality you need to specify coords for polygons in a anticlockwise direction
    // for their front face to be pointing towards you; get this wrong and you could
    // find back face culling removing the wrong faces of your models.  The OpenGL diagram
    // is just plain wrong, but it's a nice diagram so we'll keep it for now!

    // create POLYGON
    {
        // create Geometry object to store all the vertices and lines primitive.
        osg::Geometry* polyGeom = new osg::Geometry();//五百万 顶点的多边形

        // this time we'll use C arrays to initialize the vertices.
        // note, anticlockwise ordering.
        // note II, OpenGL polygons must be convex, planar polygons, otherwise
        // undefined results will occur.  If you have concave polygons or ones
        // that cross over themselves then use the osgUtil::Tessellator to fix
        // the polygons into a set of valid polygons.

		osg::Vec3Array* vertices = new osg::Vec3Array;////////////////////////////2五百万 顶点的多边形///////////////

		osg::Vec3 V1=	osg::Vec3(1, 1, 1);
		for (int n=1;n<1000001;n++)
		{
			//osg::Vec3 VTemp=	osg::Vec3(1+n, 1, 1);
			vertices->push_back(osg::Vec3(-1.0464, 0.0f, -0.193626)*n );
				vertices->push_back( osg::Vec3(-1.0258, 0.0f, -0.26778)*n );
					vertices->push_back( osg::Vec3(-0.807461, 0.0f, -0.181267)*n  );
						vertices->push_back(  osg::Vec3(-0.766264, 0.0f, -0.0576758)*n  );
							vertices->push_back(  osg::Vec3(-0.980488, 0.0f, -0.094753) *n  );
		}

	//	myCoords
  //      int numCoords = sizeof(myCoords)/sizeof(osg::Vec3);

    //    osg::Vec3Array* vertices = new osg::Vec3Array(numCoords,myCoords);

        // pass the created vertex array to the points geometry object.
        polyGeom->setVertexArray(vertices);

        polyGeom->setColorArray(shared_colors.get(), osg::Array::BIND_OVERALL);
        polyGeom->setNormalArray(shared_normals.get(), osg::Array::BIND_OVERALL);


        // This time we simply use primitive, and hardwire the number of coords to use
        // since we know up front,
        polyGeom->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::POLYGON,0,vertices->size() ) );//2五百万 顶点的多边形

    //    printTriangles("Polygon",*polyGeom);
		polyGeom->setUseDisplayList(false);
        // add the points geometry to the geode.
        geode->addDrawable(polyGeom);
    }


	// create POLYGON 2222222222222222
	{
		osg::Geometry* polyGeom = new osg::Geometry();//23百万 顶点的多边形
		osg::Vec3Array* vertices = new osg::Vec3Array;////////////////////////////3百万 顶点的多边形///////////////
		for (int n=1;n<2000001;n++)
		{
			vertices->push_back(osg::Vec3(0, 0.0f, 0)*n );
			vertices->push_back( osg::Vec3(0, 1.0f, 1)*n );
			vertices->push_back( osg::Vec3(1, 1.0f, 0)*n  );
		}
		polyGeom->setVertexArray(vertices);

		polyGeom->setColorArray(shared_colors_Red.get(), osg::Array::BIND_OVERALL);
		polyGeom->setNormalArray(shared_normals.get(), osg::Array::BIND_OVERALL);
		polyGeom->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::POLYGON,0,vertices->size() ) );//2*3百万 顶点的多边形
		polyGeom->setUseDisplayList(false);
		geode->addDrawable(polyGeom);
	}
	// create POLYGON 333333333333333333333
	{
		osg::Geometry* polyGeom = new osg::Geometry();//2*3百万 顶点的多边形
		osg::Vec3Array* vertices = new osg::Vec3Array;////////////////////////////3百万 顶点的多边形///////////////
		for (int n=1;n<2000001;n++)
		{
			vertices->push_back(osg::Vec3(0, 0.0f, 0)*n );
			vertices->push_back( osg::Vec3(1, 0.0f, 1)*n );
			vertices->push_back( osg::Vec3(1, 1.0f, 0)*n  );
		}
		polyGeom->setVertexArray(vertices);

		polyGeom->setColorArray(shared_colors_Green.get(), osg::Array::BIND_OVERALL);
		polyGeom->setNormalArray(shared_normals.get(), osg::Array::BIND_OVERALL);
		polyGeom->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::POLYGON,0,vertices->size() ) );//2*3百万 顶点的多边形
		polyGeom->setUseDisplayList(false);
		geode->addDrawable(polyGeom);
	}

    return geode;//目前累计顶点数2300w，很卡了。单次绘制glDrawArray最多顶点1250w。我目前用了四个Drawabl也就是四个glDrawArray 500，500，600，600
}


// define a node callback to animate a transform as a cycle along the y axis, between 0 and 2.0.
class MyTransformCallback : public osg::NodeCallback
{

    public:

        MyTransformCallback(float angularVelocity)
        {
            _angular_velocity = angularVelocity;
        }

        virtual void operator() (osg::Node* node, osg::NodeVisitor* nv)
        {
            osg::MatrixTransform* transform = dynamic_cast<osg::MatrixTransform*>(node);
            if (nv && transform && nv->getFrameStamp())
            {
                double time = nv->getFrameStamp()->getSimulationTime();
                transform->setMatrix(osg::Matrix::translate(0.0f,1.0f+cosf(time*_angular_velocity),0.0f));
            }

            // must continue subgraph traversal.
            traverse(node,nv);

        }

    protected:

        float               _angular_velocity;

};


osg::Node* createBackground()
{

    // we'll create a texture mapped quad to sit behind the Geometry
    osg::ref_ptr<osg::Image> image = osgDB::readRefImageFile("Images/primitives.gif");
    if (!image) return NULL;


    // create Geometry object to store all the vertices and lines primitive.
    osg::Geometry* polyGeom = new osg::Geometry();

    // note, anticlockwise ordering.
    osg::Vec3 myCoords[] =
    {
        osg::Vec3(-1.22908f,0.0f,1.0f),
        osg::Vec3(-1.22908f,0.0f,-1.0f),
        osg::Vec3(1.22908f,0.0f,-1.0f),
        osg::Vec3(1.22908f,0.0f,1.0f)
    };

    int numCoords = sizeof(myCoords)/sizeof(osg::Vec3);

    // pass the created vertex array to the points geometry object.
    polyGeom->setVertexArray(new osg::Vec3Array(numCoords,myCoords));

    osg::Vec4Array* colors = new osg::Vec4Array;
    colors->push_back(osg::Vec4(1.0f,1.0f,1.0f,1.0f));
    polyGeom->setColorArray(colors, osg::Array::BIND_OVERALL);


    // set the normal in the same way color.
    osg::Vec3Array* normals = new osg::Vec3Array;
    normals->push_back(osg::Vec3(0.0f,-1.0f,0.0f));
    polyGeom->setNormalArray(normals, osg::Array::BIND_OVERALL);

    osg::Vec2 myTexCoords[] =
    {
        osg::Vec2(0,1),
        osg::Vec2(0,0),
        osg::Vec2(1,0),
        osg::Vec2(1,1)
    };

    int numTexCoords = sizeof(myTexCoords)/sizeof(osg::Vec2);

    // pass the created tex coord array to the points geometry object,
    // and use it to set texture unit 0.
    polyGeom->setTexCoordArray(0,new osg::Vec2Array(numTexCoords,myTexCoords));

    // well use indices and DrawElements to define the primitive this time.
    unsigned short myIndices[] =
    {
        0,
        1,
        3,
        2
    };

    int numIndices = sizeof(myIndices)/sizeof(unsigned short);

    // There are three variants of the DrawElements osg::Primitive, UByteDrawElements which
    // contains unsigned char indices, UShortDrawElements which contains unsigned short indices,
    // and UIntDrawElements which contains ... unsigned int indices.
    // The first parameter to DrawElements is
    polyGeom->addPrimitiveSet(new osg::DrawElementsUShort(osg::PrimitiveSet::TRIANGLE_STRIP,numIndices,myIndices));

    // new we need to add the texture to the Drawable, we do so by creating a
    // StateSet to contain the Texture2D StateAttribute.
    osg::StateSet* stateset = new osg::StateSet;

    // set up the texture.
    osg::Texture2D* texture = new osg::Texture2D;
    texture->setImage(image);

    stateset->setTextureAttributeAndModes(0, texture,osg::StateAttribute::ON);

    polyGeom->setStateSet(stateset);


    // create the Geode (Geometry Node) to contain all our osg::Geometry objects.
    osg::Geode* geode = new osg::Geode();

    // add the points geometry to the geode.
    geode->addDrawable(polyGeom);

    //return geode;

    // create a transform to move the background back and forward with.

    osg::MatrixTransform* transform = new osg::MatrixTransform();
    transform->setUpdateCallback(new MyTransformCallback(1.0f));
    transform->addChild(geode);

    return transform;
}


osg::Node* createShareGeode( osg::Geode* geode)//by  liu chang
{

//	osg::Geode* geode = new osg::Geode();

//	geode->addDrawable(polyGeom);

	osg::MatrixTransform* transform = new osg::MatrixTransform();
	transform->setMatrix(osg::Matrix::translate(1230000,1230000,0));
	transform->addChild(geode);
	return transform;
}

int main(int, char **)
{
    // create the model
    osg::Group* root = new osg::Group;
	osg::Geode *geode=dynamic_cast<osg::Geode*>(createScene()) ;
    root->addChild( geode  );
	 root->addChild( createShareGeode(geode) );
    root->addChild( createBackground() );

    //osgDB::writeNodeFile(*root,"geoemtry.osgt");

    osgViewer::Viewer viewer;

	osgUtil::Optimizer   optimezer;
	optimezer.optimize(root);

	// add model to viewer.
	viewer.setSceneData( root );

    return viewer.run();
}
