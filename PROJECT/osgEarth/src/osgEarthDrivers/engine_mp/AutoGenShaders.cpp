// ***DO NOT EDIT THIS FILE - IT IS AUTOMATICALLY GENERATED BY CMAKE***

#include <osgEarthDrivers/engine_mp/MPShaders>

#define MULTILINE(...) #__VA_ARGS__

using namespace osgEarth::Drivers::MPTerrainEngine;

Shaders::Shaders()
{
    EngineVertexModel = "MPEngine.vert.model.glsl";
    _sources[EngineVertexModel] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR\n
$GLSL_DEFAULT_PRECISION_FLOAT\n
\n
$__HASHTAG__pragma vp_entryPoint oe_mp_vertModel\n
$__HASHTAG__pragma vp_location   vertex_model\n
$__HASHTAG__pragma vp_order      first\n
\n
out vec4 oe_layer_texc;\n
out vec4 oe_layer_tilec;\n
\n
out vec3 oe_UpVectorView;\n
out float oe_mp_terrainElev; // internal\n
in vec4 oe_terrain_attr;     // internal\n
\n
void oe_mp_vertModel(inout vec4 vertexModel)\n
{\n
    oe_layer_texc  = gl_MultiTexCoord$MP_PRIMARY_UNIT;\n
    oe_layer_tilec = gl_MultiTexCoord$MP_SECONDARY_UNIT;\n
\n
    oe_UpVectorView = gl_NormalMatrix * oe_terrain_attr.xyz;\n
\n
    // internal variable to support the oe_terrain_getElevation() SDK method\n
    // in the fragment shader stage\n
    oe_mp_terrainElev = oe_terrain_attr[3];\n
}\n
\n
);

    EngineVertexView = "MPEngine.vert.view.glsl";
    _sources[EngineVertexView] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR\n
$GLSL_DEFAULT_PRECISION_FLOAT\n
\n
$__HASHTAG__pragma vp_entryPoint oe_mp_vertView\n
$__HASHTAG__pragma vp_location   vertex_view\n
$__HASHTAG__pragma vp_order      0.5\n
\n
uniform float oe_layer_minRange;\n
uniform float oe_layer_maxRange;\n
uniform float oe_layer_attenuationRange;\n
\n
out float oe_layer_rangeOpacity;\n
\n
void oe_mp_vertView(inout vec4 vertexView)\n
{\n
    float range = max(-vertexView.z, 0.0);\n
\n
    float attenMin    = oe_layer_minRange - oe_layer_attenuationRange;\n
    float attenMax    = oe_layer_maxRange + oe_layer_attenuationRange;\n
\n
    oe_layer_rangeOpacity =\n
        oe_layer_minRange >= oe_layer_maxRange                   ? 1.0 :\n
        range >= oe_layer_minRange && range < oe_layer_maxRange  ? 1.0 :\n
        range < oe_layer_minRange                                ? clamp((range-attenMin)/oe_layer_attenuationRange, 0.0, 1.0) :\n
        range > oe_layer_maxRange                                ? clamp((attenMax-range)/oe_layer_attenuationRange, 0.0, 1.0) :\n
        0.0;\n
}\n
\n
);

    EngineFragment = "MPEngine.frag.glsl";
    _sources[EngineFragment] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR\n
$GLSL_DEFAULT_PRECISION_FLOAT\n
\n
$__HASHTAG__pragma vp_entryPoint oe_mp_apply_coloring\n
$__HASHTAG__pragma vp_location   fragment_coloring\n
$__HASHTAG__pragma vp_order      0.5\n
$__HASHTAG__pragma vp_define     MP_USE_BLENDING\n
\n
uniform bool oe_isPickCamera;\n
uniform vec4 oe_terrain_color;\n
uniform sampler2D oe_layer_tex;\n
uniform int oe_layer_uid;\n
uniform int oe_layer_order;\n
uniform float oe_layer_opacity;\n
\n
in vec4 oe_layer_texc;\n
in float oe_layer_rangeOpacity;\n
\n
void oe_mp_apply_coloring(inout vec4 color)\n
{\n
    color = oe_terrain_color.a >= 0.0 ? oe_terrain_color : color;\n
\n
    float applyImagery = oe_layer_uid >= 0 ? 1.0 : 0.0;\n
    vec4 texel = mix(color, texture2D(oe_layer_tex, oe_layer_texc.st), applyImagery);\n
    texel.a = mix(texel.a, texel.a*oe_layer_opacity*oe_layer_rangeOpacity, applyImagery);\n
\n
$__HASHTAG__ifdef MP_USE_BLENDING\n
    float firstLayer = oe_layer_order == 0 ? 1.0 : 0.0;\n
    color = mix(texel, texel*texel.a + color*(1.0-texel.a), firstLayer);    \n
$__HASHTAG__else\n
    color = texel;\n
$__HASHTAG__endif\n
\n
    // disable primary coloring for pick cameras. Necessary to support picking of\n
    // draped geometry.\n
    float pick = oe_isPickCamera ? 1.0 : 0.0;\n
    color = mix(color, vec4(0), pick);\n
}\n
\n
);

    NormalMapVertex = "MPEngine.NormalMap.vert.glsl";
    _sources[NormalMapVertex] = OE_MULTILINE($__HASHTAG__version 330 compatibility\n
\n
$__HASHTAG__pragma vp_entryPoint oe_mp_NormalMap_vertex\n
$__HASHTAG__pragma vp_location   vertex_view\n
$__HASHTAG__pragma vp_order      0.5\n
\n
uniform mat4 oe_tile_normalTexMatrix;\n
\n
// stage globals\n
vec3 vp_Normal;\n
vec4 oe_layer_tilec;\n
\n
out vec2 oe_normalMapCoords;\n
out vec3 oe_normalMapBinormal;\n
\n
void oe_mp_NormalMap_vertex(inout vec4 unused)\n
{\n
    // calculate the sampling coordinates for the normal texture\n
    oe_normalMapCoords = (oe_tile_normalTexMatrix * oe_layer_tilec).st;\n
\n
    // send the bi-normal vector to the fragment shader.\n
    oe_normalMapBinormal = gl_NormalMatrix * vec3(0,1,0);\n
}\n
\n
);

    NormalMapFragment = "MPEngine.NormalMap.frag.glsl";
    _sources[NormalMapFragment] = OE_MULTILINE($__HASHTAG__version 330 compatibility\n
\n
$__HASHTAG__pragma vp_entryPoint oe_mp_NormalMap_fragment\n
$__HASHTAG__pragma vp_location   fragment_coloring\n
$__HASHTAG__pragma vp_order      0.2\n
\n
uniform sampler2D oe_tile_normalTex;\n
\n
in vec3 vp_Normal;\n
in vec2 oe_normalMapCoords;\n
in vec3 oe_normalMapBinormal;\n
\n
void oe_mp_NormalMap_fragment(inout vec4 color)\n
{\n
    //const vec3 B = vec3(0,1,0);\n
\n
    vec4 encodedNormal = texture2D(oe_tile_normalTex, oe_normalMapCoords);\n
    vec3 normal        = normalize(encodedNormal.xyz*2.0-1.0);\n
\n
    //vp_Normal = normalize(oe_mp_NormalMap_TBN * normalTangent);\n
\n
    vec3 tangent = normalize(cross(oe_normalMapBinormal, vp_Normal));\n
\n
    vp_Normal = normalize(mat3(tangent, oe_normalMapBinormal, vp_Normal) * normal);\n
\n
    // visualize curvature gradient:\n
    //color.rgb = vec3(0,0,0);\n
    //color.r = (encodedNormal.a+1.0)/2.0;\n
    //color.b = 1.0-color.r;\n
\n
    // visualize curvature quantized:\n
    //if(encodedNormal.a >= 0.4) color.r = 1.0;\n
    //if(encodedNormal.a <= -0.4) color.b = 1.0;\n
    \n
    // visualize normals:\n
    //color.rgb = encodedNormal.xyz;\n
}\n
\n
);
}
