// ***DO NOT EDIT THIS FILE - IT IS AUTOMATICALLY GENERATED BY CMAKE***

#include <osgEarthDrivers/engine_rex/Shaders>

#define MULTILINE(...) #__VA_ARGS__

using namespace osgEarth::Drivers::RexTerrainEngine;

Shaders::Shaders()
{
    ENGINE_VERT_MODEL = "RexEngine.vert.glsl";
    _sources[ENGINE_VERT_MODEL] = OE_MULTILINE($__HASHTAG__version 330 compatibility\n
\n
$__HASHTAG__pragma vp_name       REX Engine - Vertex\n
$__HASHTAG__pragma vp_entryPoint oe_rexEngine_vert\n
$__HASHTAG__pragma vp_location   vertex_model\n
$__HASHTAG__pragma vp_order      0.0\n
\n
// uniforms\n
uniform vec4 oe_terrain_color;\n
\n
// outputs\n
out vec4 vp_Color;\n
out vec3 vp_Normal;\n
\n
out vec4 oe_layer_texc;\n
out vec4 oe_layer_tilec;\n
out vec3 oe_UpVectorView;\n
\n
out float oe_rex_morphFactor;\n
\n
void oe_rexEngine_vert(inout vec4 vertexModel)\n
{\n
    // Texture coordinate for the tile (always 0..1)\n
    oe_layer_tilec = gl_MultiTexCoord0;\n
\n
    // Color of the underlying map geometry (untextured)\n
    vp_Color = oe_terrain_color;\n
	\n
    // "up" vector at this vertex in view space, which we will later\n
    // need in order to elevate the terrain\n
	oe_UpVectorView = normalize(gl_NormalMatrix*vp_Normal);\n
\n
    // initialize:\n
    oe_rex_morphFactor = 0.0;\n
}\n
\n
);

    MORPHING_VERT = "RexEngine.Morphing.vert.glsl";
    _sources[MORPHING_VERT] = OE_MULTILINE($__HASHTAG__version 330 compatibility\n
\n
$__HASHTAG__pragma vp_name       REX Engine - Morphing\n
$__HASHTAG__pragma vp_entryPoint oe_rexEngine_morph\n
$__HASHTAG__pragma vp_location   vertex_model\n
$__HASHTAG__pragma vp_order      0.5\n
$__HASHTAG__pragma vp_define     OE_REX_VERTEX_MORPHING\n
\n
// stage\n
vec3 vp_Normal; // up vector\n
\n
vec4 oe_layer_texc;\n
vec4 oe_layer_tilec;\n
\n
out float oe_rex_morphFactor;\n
\n
uniform sampler2D oe_tile_elevationTex;\n
uniform mat4      oe_tile_elevationTexMatrix;\n
uniform vec2	  oe_tile_morph;\n
uniform float     oe_tile_size;\n
uniform vec4	  oe_tile_key;\n
\n
// SDK functions:\n
float oe_terrain_getElevation(in vec2 uv);\n
\n
// Vertex Markers:\n
$__HASHTAG__define MASK_MARKER_DISCARD  0.0\n
$__HASHTAG__define MASK_MARKER_NORMAL   1.0\n
$__HASHTAG__define MASK_MARKER_SKIRT    2.0\n
$__HASHTAG__define MASK_MARKER_BOUNDARY 3.0\n
\n
\n
// Morphs a vertex using a neighbor.\n
void oe_rex_MorphVertex(inout vec3 position, inout vec2 uv, in vec3 neighborPosition)\n
{\n
   float halfSize        = (0.5*oe_tile_size)-0.5;\n
   float twoOverHalfSize = 2.0/(oe_tile_size-1.0);\n
   \n
   vec2 fractionalPart = fract(uv * halfSize) * twoOverHalfSize;\n
   uv = clamp(uv - (fractionalPart * oe_rex_morphFactor), 0.0, 1.0);\n
   //uv = clamp(uv, 0, 1);\n
\n
   vec3 morphVector = neighborPosition.xyz - position.xyz;\n
   position.xyz = position.xyz + morphVector*oe_rex_morphFactor;\n
}\n
\n
\n
// Compute a morphing factor based on model-space inputs:\n
float oe_rex_ComputeMorphFactor(in vec4 position, in vec3 up)\n
{\n
    // Find the "would be" position of the vertex (the position the vertex would\n
    // assume with no morphing)\n
	vec4 wouldBePosition = position;\n
\n
	$__HASHTAG__ifdef OE_REX_VERTEX_MORPHING\n
        float elev = oe_terrain_getElevation( oe_layer_tilec.st );\n
		wouldBePosition.xyz += up*elev;\n
	$__HASHTAG__endif\n
\n
    vec4 wouldBePositionView = gl_ModelViewMatrix * wouldBePosition;\n
    \n
    float fDistanceToEye = length(wouldBePositionView.xyz); // or just -z.\n
	float fMorphLerpK  = 1.0f - clamp( oe_tile_morph[0] - fDistanceToEye * oe_tile_morph[1], 0.0, 1.0 );\n
    return fMorphLerpK;\n
}\n
\n
\n
void oe_rexEngine_morph(inout vec4 vertexModel)\n
{    \n
    // compute the morphing factor to send down the pipe.\n
    // we need this even if vertex-morphing is off since we use it for \n
    // other things (like image blending)\n
    if (oe_layer_tilec.z == MASK_MARKER_NORMAL)\n
    {\n
        oe_rex_morphFactor = oe_rex_ComputeMorphFactor(vertexModel, vp_Normal);    \n
\n
$__HASHTAG__ifdef OE_REX_VERTEX_MORPHING\n
        vec3 neighborVertexModel = gl_MultiTexCoord1.xyz;\n
        oe_rex_MorphVertex(vertexModel.xyz, oe_layer_tilec.st, neighborVertexModel.xyz);\n
$__HASHTAG__endif\n
    }\n
    else\n
    {\n
        oe_rex_morphFactor = 0.0;\n
    }\n
}\n
\n
\n
);

    ENGINE_VERT_VIEW = "RexEngine.vert.view.glsl";
    _sources[ENGINE_VERT_VIEW] = OE_MULTILINE($__HASHTAG__version 330 compatibility\n
\n
$__HASHTAG__pragma vp_name       REX Engine - Vertex/View\n
$__HASHTAG__pragma vp_entryPoint oe_rex_elevateVertexAndSetTexCoords\n
$__HASHTAG__pragma vp_location   vertex_view\n
$__HASHTAG__pragma vp_order      0.4\n
\n
// Stage globals\n
vec4 oe_layer_tilec;\n
vec4 oe_layer_texc;\n
vec4 oe_layer_texcParent;\n
vec3 oe_UpVectorView;\n
\n
vec4 vp_Color;\n
\n
uniform mat4 oe_layer_texMatrix;\n
uniform mat4 oe_layer_texParentMatrix;\n
\n
// SDK functions:\n
float oe_terrain_getElevation(in vec2 uv);\n
\n
// Vertex Markers:\n
$__HASHTAG__define MASK_MARKER_DISCARD  0.0\n
$__HASHTAG__define MASK_MARKER_NORMAL   1.0\n
$__HASHTAG__define MASK_MARKER_SKIRT    2.0\n
$__HASHTAG__define MASK_MARKER_BOUNDARY 3.0\n
\n
void oe_rex_elevateVertexAndSetTexCoords(inout vec4 vertexView)\n
{\n
    float elev = \n
        oe_layer_tilec.z == MASK_MARKER_BOUNDARY || oe_layer_tilec.z == MASK_MARKER_DISCARD ? 0.0f\n
        : oe_terrain_getElevation( oe_layer_tilec.st );\n
\n
    vertexView.xyz += oe_UpVectorView * elev;\n
\n
$__HASHTAG__if 0\n
    // calculate the texture coordinates:\n
    oe_layer_texc       = oe_layer_texMatrix       * oe_layer_tilec;\n
	oe_layer_texcParent = oe_layer_texParentMatrix * oe_layer_tilec;\n
$__HASHTAG__else\n
    // faster (MAD)\n
	oe_layer_texc.xy	   = oe_layer_tilec.xy*oe_layer_texMatrix[0][0] + oe_layer_texMatrix[3].xy;\n
    oe_layer_texc.zw       = oe_layer_tilec.zw;\n
    oe_layer_texcParent.xy = oe_layer_tilec.xy*oe_layer_texParentMatrix[0][0] + oe_layer_texParentMatrix[3].xy;\n
    oe_layer_texcParent.zw = oe_layer_tilec.zw;\n
$__HASHTAG__endif\n
}\n
\n
);

    ENGINE_FRAG = "RexEngine.frag.glsl";
    _sources[ENGINE_FRAG] = OE_MULTILINE($__HASHTAG__version 330\n
\n
$__HASHTAG__pragma vp_name       REX Engine - Fragment\n
$__HASHTAG__pragma vp_entryPoint oe_rexEngine_frag\n
$__HASHTAG__pragma vp_location   fragment_coloring\n
$__HASHTAG__pragma vp_order      0.5\n
$__HASHTAG__pragma vp_define     OE_REX_GL_BLENDING\n
$__HASHTAG__pragma vp_define     OE_REX_MORPH_IMAGERY\n
\n
uniform bool      oe_isPickCamera;\n
uniform sampler2D oe_layer_tex;\n
uniform int       oe_layer_uid;\n
uniform int       oe_layer_order;\n
uniform float     oe_layer_opacity;\n
\n
$__HASHTAG__ifdef OE_REX_MORPH_IMAGERY\n
uniform sampler2D oe_layer_texParent;\n
uniform float oe_layer_texParentExists;\n
in vec4 oe_layer_texcParent;\n
in float oe_rex_morphFactor;\n
$__HASHTAG__endif\n
\n
in vec4 oe_layer_texc;\n
\n
void oe_rexEngine_frag(inout vec4 color)\n
{\n
    float applyImagery = oe_layer_uid >= 0 ? 1.0 : 0.0;\n
    \n
	vec4 texelSelf = texture(oe_layer_tex, oe_layer_texc.st);\n
\n
$__HASHTAG__ifdef OE_REX_MORPH_IMAGERY\n
\n
    // sample the parent texture:\n
	vec4 texelParent = texture(oe_layer_texParent, oe_layer_texcParent.st);\n
\n
    // if the parent texture does not exist, use the current texture with alpha=0 as the parent\n
    // so we can "fade in" an image layer that starts at LOD > 0:\n
    texelParent = mix( vec4(texelSelf.rgb, 0.0), texelParent, oe_layer_texParentExists );\n
\n
    // Resolve the final texel color:\n
	vec4 texel = mix(texelSelf, texelParent, oe_rex_morphFactor);\n
\n
    // Decide whether to use the texel or the incoming color:\n
	texel = mix(color, texel, applyImagery);\n
\n
$__HASHTAG__else\n
\n
    // No morphing, just use the incoming color or texture:\n
    vec4 texel = mix(color, texelSelf, applyImagery);\n
\n
$__HASHTAG__endif\n
\n
    // Integrate layer opacity into the texture:\n
    texel.a = mix(texel.a, texel.a*oe_layer_opacity, applyImagery);\n
\n
    float firstLayer = (applyImagery == 1.0 && oe_layer_order == 0) ? 1.0 : 0.0;\n
\n
$__HASHTAG__ifdef OE_REX_GL_BLENDING\n
\n
    // If this is the first image layer, simply replace the color with the texture.\n
    // Otherwise, blend the texture with the incoming color value.\n
    color = mix(texel, texel*texel.a + color*(1.0-texel.a), firstLayer);\n
\n
$__HASHTAG__else\n
\n
    // No blending? The output is just the texel value.\n
    color = texel;\n
\n
$__HASHTAG__endif\n
\n
    // disable primary coloring for pick cameras. Necessary to support picking of\n
    // draped geometry.\n
    float pick = oe_isPickCamera ? 1.0 : 0.0;\n
    color = mix(color, vec4(0), pick);\n
}\n
\n
);

    NORMAL_MAP_VERT = "RexEngine.NormalMap.vert.glsl";
    _sources[NORMAL_MAP_VERT] = OE_MULTILINE($__HASHTAG__version 330 compatibility\n
\n
$__HASHTAG__pragma vp_entryPoint oe_normalMapVertex\n
$__HASHTAG__pragma vp_location   vertex_view\n
$__HASHTAG__pragma vp_order      0.5\n
\n
uniform mat4 oe_tile_normalTexMatrix;\n
\n
// stage globals\n
vec4 oe_layer_tilec;\n
\n
out vec2 oe_normalMapCoords;\n
out vec3 oe_normalMapBinormal;\n
\n
void oe_normalMapVertex(inout vec4 unused)\n
{\n
    // calculate the sampling coordinates for the normal texture\n
    oe_normalMapCoords = (oe_tile_normalTexMatrix * oe_layer_tilec).st;\n
\n
    // send the bi-normal to the fragment shader\n
    oe_normalMapBinormal = gl_NormalMatrix * vec3(0,1,0);\n
}\n
\n
);

    NORMAL_MAP_FRAG = "RexEngine.NormalMap.frag.glsl";
    _sources[NORMAL_MAP_FRAG] = OE_MULTILINE($__HASHTAG__version 330 compatibility\n
\n
$__HASHTAG__pragma vp_entryPoint oe_normalMapFragment\n
$__HASHTAG__pragma vp_location   fragment_coloring\n
$__HASHTAG__pragma vp_order      0.2\n
\n
// import terrain SDK\n
vec4 oe_terrain_getNormalAndCurvature(in vec2);\n
\n
uniform sampler2D oe_tile_normalTex;\n
\n
in vec3 vp_Normal;\n
in vec3 oe_UpVectorView;\n
in vec2 oe_normalMapCoords;\n
in vec3 oe_normalMapBinormal;\n
\n
void oe_normalMapFragment(inout vec4 color)\n
{\n
    vec4 encodedNormal = oe_terrain_getNormalAndCurvature(oe_normalMapCoords);\n
    //vec4 encodedNormal = texture2D(oe_tile_normalTex, oe_normalMapCoords);\n
    vec3 normal = normalize(encodedNormal.xyz*2.0-1.0);\n
\n
    vec3 tangent = normalize(cross(oe_normalMapBinormal, oe_UpVectorView));\n
    vp_Normal = normalize( mat3(tangent, oe_normalMapBinormal, oe_UpVectorView) * normal );\n
\n
    // visualize curvature gradient:\n
    //color.rgb = vec3(0,0,0);\n
    //color.r = (encodedNormal.a+1.0)/2.0;\n
    //color.b = 1.0-color.r;\n
\n
    // visualize curvature quantized:\n
    //if(encodedNormal.a >= 0.4) color.r = 1.0;\n
    //if(encodedNormal.a <= -0.4) color.b = 1.0;\n
    \n
    // visualize normals:\n
    //color.rgb = encodedNormal.xyz;\n
}\n
\n
);

    ENGINE_GEOM = "RexEngine.gs.glsl";
    _sources[ENGINE_GEOM] = OE_MULTILINE($__HASHTAG__version 330 compatibility\n
\n
\n
$__HASHTAG__if 0 // currently unused - triangle discard implemented on CPU instead\n
\n
$__HASHTAG__pragma vp_name       REX Engine - GS\n
$__HASHTAG__pragma vp_entryPoint oe_rexEngine_gs\n
$__HASHTAG__pragma vp_location   geometry\n
\n
// Vertex Markers:\n
$__HASHTAG__define MASK_MARKER_DISCARD  0.0\n
$__HASHTAG__define MASK_MARKER_NORMAL   1.0\n
$__HASHTAG__define MASK_MARKER_SKIRT    2.0\n
$__HASHTAG__define MASK_MARKER_BOUNDARY 3.0\n
\n
layout(triangles)      in;\n
layout(triangle_strip) out;\n
layout(max_vertices=3) out;\n
\n
void VP_LoadVertex(in int);\n
void VP_EmitModelVertex();\n
\n
in vec4 oe_layer_tilec;\n
\n
void oe_rexEngine_gs(void)\n
{\n
    for(int i=0; i < 3; ++i )\n
    {\n
        VP_LoadVertex(i);\n
        if ( oe_layer_tilec.z == MASK_MARKER_DISCARD )\n
            return;\n
    }\n
\n
    for(int i=0; i < 3; ++i )\n
    {\n
        VP_LoadVertex(i);\n
        gl_Position = gl_in[i].gl_Position;\n
        VP_EmitModelVertex();\n
    }\n
    EndPrimitive();\n
}\n
\n
$__HASHTAG__endif\n
\n
);

    SDK = "RexEngine.SDK.vert.glsl";
    _sources[SDK] = OE_MULTILINE($__HASHTAG__version 330\n
$__HASHTAG__pragma vp_name Rex Terrain SDK\n
\n
/**\n
 * SDK functions for the Rex engine.\n
 * Declare and call these from any shader that runs on the terrain.\n
 */\n
\n
// uniforms from terrain engine\n
uniform sampler2D oe_tile_elevationTex;\n
uniform mat4 oe_tile_elevationTexMatrix;\n
uniform vec2 oe_tile_elevTexelCoeff;\n
\n
uniform sampler2D oe_tile_normalTex;\n
uniform mat4 oe_tile_normalTexMatrix;\n
\n
uniform vec4 oe_tile_key;\n
\n
// Stage global\n
vec4 oe_layer_tilec;\n
\n
\n
/**\n
 * Sample the elevation data at a UV tile coordinate.\n
 */\n
float oe_terrain_getElevation(in vec2 uv)\n
{\n
    // Texel-level scale and bias allow us to sample the elevation texture\n
    // on texel center instead of edge.\n
    vec2 elevc = uv\n
        * oe_tile_elevTexelCoeff.x * oe_tile_elevationTexMatrix[0][0]     // scale\n
        + oe_tile_elevTexelCoeff.x * oe_tile_elevationTexMatrix[3].st     // bias\n
        + oe_tile_elevTexelCoeff.y;                                      \n
\n
    return texture(oe_tile_elevationTex, elevc).r;\n
}\n
\n
/**\n
 * Read the elevation at the build-in tile coordinates (convenience)\n
 */\n
float oe_terrain_getElevation()\n
{\n
    return oe_terrain_getElevation(oe_layer_tilec.st);\n
}\n
\n
/**\n
 * Read the normal vector and curvature at resolved UV tile coordinates.\n
 */\n
vec4 oe_terrain_getNormalAndCurvature(in vec2 uv_scaledBiased)\n
{\n
    return texture(oe_tile_normalTex, uv_scaledBiased);\n
}\n
\n
vec4 oe_terrain_getNormalAndCurvature()\n
{\n
    vec2 uv_scaledBiased = oe_layer_tilec.st * oe_tile_normalTexMatrix[0][0] + oe_tile_normalTexMatrix[3].st;\n
    return texture(oe_tile_normalTex, uv_scaledBiased);\n
}\n
\n
/**\n
 * Scales repeating texture coordinate such that they are [0..1]\n
 * at a specific reference tile LOD. \n
 */\n
vec2 oe_terrain_scaleCoordsToRefLOD(in vec2 tc, in float refLOD)\n
{\n
    float dL = oe_tile_key.z - refLOD;\n
    float factor = exp2(dL);\n
    float invFactor = 1.0/factor;\n
    vec2 result = tc * vec2(invFactor);\n
    if ( factor >= 1.0 ) {\n
        vec2 a = floor(oe_tile_key.xy * invFactor);\n
        vec2 b = a * factor;\n
        vec2 c = b + factor;\n
        result += (oe_tile_key.xy-b)/(c-b);\n
    }\n
    return result;\n
}\n
\n
);
}
